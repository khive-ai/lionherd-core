# Migration Guide: v1.0.0-alpha5

> Comprehensive guide for migrating from v1.0.0-alpha4 to v1.0.0-alpha5

**Release Date**: TBD
**Status**: Pre-release
**Breaking Changes**: 11 major changes across Pile, Flow, and Progression

---

## Overview

Version 1.0.0-alpha5 introduces significant API improvements focused on:

- **Immutable configuration** - Frozen fields prevent runtime type confusion
- **Semantic clarity** - Return values indicate guaranteed state
- **Dict-like protocol** - Align Pile with Python's mapping interface
- **Stricter validation** - Fail-fast on invalid data
- **Referential integrity** - Flow validates progression references at construction

All breaking changes are intentional design improvements based on multi-alpha evolution.

---

## Quick Reference

| Component | Change | Action Required | Complexity |
|-----------|--------|----------------|-----------|
| **Pile.item_type/strict_type** | Now frozen | Set at initialization | Low |
| **Pile.include/exclude** | Return semantics changed | Reinterpret return value | Medium |
| **Pile.items** | Property → method | Add `()` to call | Low |
| **Pile.keys()** | Generator → Iterator | No change needed | None |
| **Pile async methods** | Removed | Use sync methods | Low |
| **Pile.__list__/to_list** | Removed | Use `list(pile)` | Low |
| **Progression.__init__** | Removed (internal) | No change needed | None |
| **Progression validation** | Stricter | Fix invalid data | Medium |
| **Progression.__bool__** | Added | Update boolean checks | Low |
| **Flow.__init__** | Signature redesigned | Check progressions param | Low |
| **Flow validation** | Added integrity check | Ensure references exist | Medium |
| **Flow.add_item** | Parameter renamed | `progression_ids` → `progressions` | Low |
| **Flow.remove_item** | Always removes from progressions | Remove `remove_from_progressions` param | Medium |
| **@implements()** | Strict enforcement | Define protocol methods in class body | High |
| **Adaptable protocols** | Split into read/write | Add `AdapterRegisterable` if needed | Medium |

---

## Pile Changes

### 1. Frozen Type Configuration

**Breaking Change**: `item_type` and `strict_type` fields are now frozen and cannot be mutated after initialization.

#### Before (v1.0.0-alpha4)

```python
from lionherd_core import Pile, Node

# Could mutate type configuration after creation
pile = Pile()
pile.item_type = {Node}     # ✓ Worked
pile.strict_type = True     # ✓ Worked
```

#### After (v1.0.0-alpha5)

```python
from lionherd_core import Pile, Node

# Type configuration is frozen
pile = Pile()
pile.item_type = {Node}     # ❌ ValidationError: Field is frozen
pile.strict_type = True     # ❌ ValidationError: Field is frozen

# ✅ CORRECT: Set at initialization
pile = Pile(item_type=Node, strict_type=True)
```

#### Migration Steps

1. **Identify all Pile instantiations** that later mutate `item_type` or `strict_type`
2. **Move configuration to constructor**:

```python
# Before
pile = Pile()
pile.item_type = MyNode
pile.strict_type = True
pile.add(item)

# After
pile = Pile(item_type=MyNode, strict_type=True)
pile.add(item)
```

3. **For Flow-managed Piles**, pass configuration to Flow constructor:

```python
# Before - configuration might be lost
pile = Pile(item_type=MyNode)
flow = Flow(items=list(pile))  # Lost type config!

# After - configuration preserved
flow = Flow(items=pile)  # ✅ Accepts Pile directly
# OR
flow = Flow(items=[...], item_type=MyNode, strict_type=True)
```

#### Rationale

Type configuration is structural - changing it after initialization would invalidate existing items. Frozen fields:

- Prevent runtime type confusion
- Make Pile behavior predictable
- Follow Rust's "configuration at construction" pattern
- Enable optimizations (type checks can be cached)

**See also**: [Flow.__init__ redesign](#8-flow-constructor-redesign) for related changes.

---

### 2. include/exclude Return Semantics

**Breaking Change**: `include()` and `exclude()` now return guaranteed state (True = is in pile) rather than action taken (True = was added).

#### Before (v1.0.0-alpha4)

```python
from lionherd_core import Pile, Node

pile = Pile()
node = Node(content={"key": "value"})

# Return value indicated action taken
was_added = pile.include(node)       # True = added, False = already present
was_removed = pile.exclude(node)     # True = removed, False = not present

# Common pattern: check if action was taken
if pile.include(node):
    print("Node was just added")
else:
    print("Node already existed")
```

#### After (v1.0.0-alpha5)

```python
from lionherd_core import Pile, Node

pile = Pile()
node = Node(content={"key": "value"})

# Return value indicates guaranteed state
is_in_pile = pile.include(node)      # True = IS in pile (added or was present)
is_not_in_pile = pile.exclude(node)  # True = IS NOT in pile (removed or wasn't present)

# New pattern: check guaranteed state
if pile.include(node):
    # Guaranteed: node is in pile (safe to proceed)
    process_node(node)
else:
    # Failed: validation error (node could not be added)
    handle_error(node)
```

#### Migration Steps

1. **Update interpretation of return value**:

```python
# Before - checking if action was taken
if pile.include(item):
    log(f"Added {item}")

# After - checking guaranteed state
if pile.include(item):
    # Item is guaranteed to be in pile (added OR already present)
    log(f"Ensured {item} is in pile")
```

2. **If you need to detect "was added" behavior**, check before including:

```python
# Detecting first-time addition
was_present = item.id in pile
pile.include(item)
if not was_present:
    log(f"Newly added {item}")
```

3. **Update error handling** - operations now return False instead of raising:

```python
# Before - exceptions bubbled up
try:
    pile.include(invalid_item)
except ValidationError:
    handle_error()

# After - exceptions suppressed, returns False
if not pile.include(invalid_item):
    handle_error()  # Validation failed
```

#### Idiomatic Patterns

```python
# ✅ Guarantee membership before proceeding
if pile.include(item):
    # Guaranteed: item is in pile
    next_operation(pile, item)
else:
    # Item failed validation
    log_error(f"Cannot add {item}")

# ✅ Guarantee absence before adding replacement
if pile.exclude(old_item):
    # Guaranteed: old_item is not in pile
    pile.include(new_item)

# ✅ Idempotent bulk operations
for item in items:
    pile.include(item)  # Safe to call multiple times
```

#### Rationale

Previous semantics (True = action taken) required separate existence checks to know current state:

```python
# Before - needed two operations to guarantee state
if item.id not in pile:  # Check existence
    pile.include(item)    # Then add
```

New semantics (True = guaranteed state) make `include/exclude` truly idempotent:

```python
# After - single operation guarantees state
if pile.include(item):   # Guarantees item is in pile
    use(item)             # Safe to proceed
```

Exception suppression makes operations safe for bulk processing without try/except blocks.

---

### 3. Dict-like Iteration Protocol

**Breaking Change**: `.items` changed from property to method, returning `Iterator[tuple[UUID, T]]` for dict-like consistency.

#### Before (v1.0.0-alpha4)

```python
from lionherd_core import Pile, Node

pile = Pile(items=[Node(content={"x": i}) for i in range(3)])

# .items was a property (MappingProxyType)
items_view = pile.items
items_view[uuid]  # Direct key access

# .keys() returned generator
keys = pile.keys()
next(keys)  # Generator iteration
```

#### After (v1.0.0-alpha5)

```python
from lionherd_core import Pile, Node

pile = Pile(items=[Node(content={"x": i}) for i in range(3)])

# .items() is now a method (Iterator[tuple[UUID, T]])
for uuid, item in pile.items():  # Note: items() not items
    process(uuid, item)

# .keys() returns Iterator[UUID] (same usage)
for uuid in pile.keys():
    item = pile[uuid]

# Full dict-like protocol
list(pile.keys())    # [uuid1, uuid2, uuid3, ...]
list(pile.values())  # [item1, item2, item3, ...]
list(pile.items())   # [(uuid1, item1), (uuid2, item2), ...]
```

#### Migration Steps

1. **Change `.items` property access to `.items()` method call**:

```python
# Before
for uuid, item in pile.items.items():  # Note: .items.items()
    process(uuid, item)

# After
for uuid, item in pile.items():  # Note: .items()
    process(uuid, item)
```

2. **No changes needed for `.keys()` usage** (signature changed internally, but API is compatible):

```python
# Both work the same
for uuid in pile.keys():
    item = pile[uuid]
```

3. **For direct key access**, use `pile[uuid]` instead:

```python
# Before
value = pile.items[uuid]  # MappingProxyType subscript

# After
value = pile[uuid]  # Direct Pile subscript
```

#### Full Dict-like Protocol

```python
from lionherd_core import Pile, Node

pile = Pile(items=[Node(content={"x": i}) for i in range(3)])

# Keys (insertion order)
for uuid in pile.keys():
    print(f"UUID: {uuid}")

# Values (insertion order, same as: for item in pile)
for item in pile.values():
    print(f"Item: {item}")

# Items (insertion order)
for uuid, item in pile.items():
    print(f"{uuid}: {item}")

# Direct iteration (unchanged)
for item in pile:
    process(item)

# Membership testing (unchanged)
if uuid in pile:
    item = pile[uuid]

# Length (unchanged)
print(f"Pile contains {len(pile)} items")
```

#### Rationale

Aligns Pile with Python's `dict` protocol:

- **Consistency**: `.keys()`, `.values()`, `.items()` match dict API
- **Pythonic**: Works with dict-expecting code (e.g., `dict(pile.items())`)
- **Type safety**: Iterator return type (vs generator) provides cleaner signatures
- **First-class mapping**: Pile becomes a true dict-like collection

Python developers expect mapping types to have these three methods. Previous design (`.items` property) was non-standard.

---

### 4. Removed Async Methods

**Breaking Change**: Async variants removed: `add_async()`, `remove_async()`, `get_async()`. Use sync methods instead.

#### Before (v1.0.0-alpha4)

```python
from lionherd_core import Pile, Node

async def process():
    pile = Pile()
    node = Node(content={"key": "value"})

    # Async variants existed
    await pile.add_async(node)
    item = await pile.get_async(node.id)
    removed = await pile.remove_async(node.id)
```

#### After (v1.0.0-alpha5)

```python
from lionherd_core import Pile, Node

async def process():
    pile = Pile()
    node = Node(content={"key": "value"})

    # Use sync methods (O(1) CPU-bound operations)
    pile.add(node)              # Sync call
    item = pile[node.id]        # Sync call
    removed = pile.remove(node.id)  # Sync call
```

#### Migration Steps

1. **Replace all async Pile methods with sync equivalents**:

```python
# Before
await pile.add_async(item)
item = await pile.get_async(uuid)
removed = await pile.remove_async(uuid)

# After
pile.add(item)          # Sync (O(1) dict operation)
item = pile[uuid]       # Sync (O(1) dict lookup)
removed = pile.remove(uuid)  # Sync (O(1) dict removal)
```

2. **For thread-safe bulk operations, use async context manager**:

```python
# ✅ Async context manager for thread-safe bulk operations
async with pile:
    pile.add(item1)
    pile.add(item2)
    pile.add(item3)
    # Lock held across all operations
```

3. **No await needed** - operations are synchronous:

```python
async def workflow():
    pile = Pile()

    # All synchronous (no await)
    pile.add(item1)
    pile.add(item2)

    # Async operations on OTHER objects still work
    result = await some_async_function()

    # Pile operations remain sync
    pile.add(result)
```

#### Rationale

Pile operations are **O(1) in-memory dict operations** (CPU-bound, not I/O):

- **No I/O**: Dict add/remove/lookup doesn't benefit from async
- **Complexity**: Async variants complicated API surface for zero benefit
- **Thread safety**: Provided via async context manager (`async with pile:`)
- **Best practices**: Python convention is sync for CPU-bound, async for I/O-bound

**Performance**: Sync dict operations are ~10-20% faster than async equivalents (no coroutine overhead).

Async context manager still available for scenarios requiring lock acquisition across multiple operations.

---

### 5. Removed List Methods

**Breaking Change**: `__list__()` and `to_list()` methods removed. Use built-in `list()` constructor instead.

#### Before (v1.0.0-alpha4)

```python
from lionherd_core import Pile, Node

pile = Pile(items=[Node(content={"x": i}) for i in range(3)])

# Two ways to get list
items = pile.__list__()  # Dunder method
items = pile.to_list()   # Explicit method
```

#### After (v1.0.0-alpha5)

```python
from lionherd_core import Pile, Node

pile = Pile(items=[Node(content={"x": i}) for i in range(3)])

# Use standard Python pattern
items = list(pile)  # ✅ Pythonic, works with any iterable
```

#### Migration Steps

Simple search and replace:

```python
# Before
items = pile.to_list()
items = pile.__list__()

# After
items = list(pile)
```

#### Rationale

- **`__list__()` is not a Python protocol** (unlike `__iter__`, `__len__`, `__contains__`)
- **Duplication**: Both `__list__()` and `to_list()` provided identical functionality
- **Pythonic**: `list(pile)` is idiomatic and works consistently with all iterables
- **Standard library**: Python uses `list(x)` for sequences, sets, dicts, generators

Removing custom list methods reduces API surface and aligns with Python conventions.

---

## Progression Changes

### 6. Removed Custom __init__

**Breaking Change**: Custom `__init__` removed - all normalization moved to `@field_validator` (Pydantic V2 pattern).

#### Before (v1.0.0-alpha4)

```python
from lionherd_core import Progression, Node

# Custom __init__ handled normalization
node1, node2 = Node(content={"x": 1}), Node(content={"x": 2})

prog = Progression(order=[node1, node2])  # Elements converted in __init__
# Behind the scenes: __init__ converted Elements to UUIDs
```

#### After (v1.0.0-alpha5)

```python
from lionherd_core import Progression, Node

# Field validator handles normalization
node1, node2 = Node(content={"x": 1}), Node(content={"x": 2})

prog = Progression(order=[node1, node2])  # Elements converted in validator
# Behind the scenes: @field_validator converts Elements to UUIDs
```

#### Migration Steps

**No code changes required** - usage is identical. Only internal implementation changed.

```python
# ✅ All these still work
from uuid import uuid4

prog = Progression(order=[uuid4(), uuid4()])  # UUIDs
prog = Progression(order=[node1, node2])      # Elements
prog = Progression(order=["uuid-str-1", "uuid-str-2"])  # UUID strings
prog = Progression(order=None)                # Empty progression
```

#### Breaking Behavior Change: Stricter Validation

**Exception behavior changed** - invalid items now raise exceptions instead of being silently dropped:

```python
from lionherd_core import Progression
from uuid import uuid4

valid_uuid = uuid4()
invalid_item = "not-a-uuid"

# Before (v1.0.0-alpha4) - silent dropping
prog = Progression(order=[valid_uuid, invalid_item, uuid4()])
# Result: order=[valid_uuid, uuid4()]  (invalid_item silently dropped)

# After (v1.0.0-alpha5) - raises exception
prog = Progression(order=[valid_uuid, invalid_item, uuid4()])
# Result: ❌ ValidationError: Cannot coerce 'not-a-uuid' to UUID
```

**Migration**: Fix invalid data sources:

```python
# If you relied on silent dropping, filter invalid items first
from uuid import UUID

def is_valid_uuid(item):
    try:
        UUID(str(item)) if not isinstance(item, UUID) else item
        return True
    except (ValueError, AttributeError):
        return False

# Filter before passing to Progression
valid_items = [item for item in items if is_valid_uuid(item)]
prog = Progression(order=valid_items)
```

#### Rationale

- **Pydantic best practice**: Field validators are correct place for normalization
- **Single validation path**: Eliminates dual validation (`__init__` + validator)
- **Fail-fast**: Stricter validation prevents silent data loss
- **Explicit errors**: Clear error messages for invalid data

**Note**: This is a **behavioral breaking change** if you relied on silent dropping of invalid items.

---

### 7. Added __bool__ Protocol

**Breaking Change**: Progression now implements `__bool__` - empty progressions are falsy.

#### Before (v1.0.0-alpha4)

```python
from lionherd_core import Progression

prog = Progression()  # Empty
bool(prog)  # True (default object truthiness)

if prog:
    print("This always executed")
```

#### After (v1.0.0-alpha5)

```python
from lionherd_core import Progression
from uuid import uuid4

# Empty progression is falsy
prog = Progression()
bool(prog)  # False

if prog:
    print("This does NOT execute for empty progression")

# Non-empty progression is truthy
prog = Progression(order=[uuid4()])
bool(prog)  # True
```

#### Migration Steps

1. **Update boolean checks if you relied on always-truthy behavior**:

```python
# Before - prog was always truthy
if prog:
    process(prog)

# After - check for None explicitly if needed
if prog is not None:
    process(prog)

# Or embrace new semantics (recommended)
if prog:  # Now checks if non-empty
    process(prog)
```

2. **Explicit length checks still work** (unchanged):

```python
# These patterns still work
if len(prog) > 0:
    process(prog)

if prog.order:  # Check internal list
    process(prog)
```

#### Rationale

Standard Python protocol: empty containers are falsy

- `[]` → False
- `{}` → False
- `set()` → False
- `""` → False

Makes Progression consistent with Python's truthiness semantics:

```python
# Pythonic idioms now work
if not progression:
    print("No items to process")

if progression:
    for uuid in progression:
        process(uuid)
```

---

### 8. Exception Changes: IndexError → NotFoundError

**Breaking Change**: Progression methods now raise `NotFoundError` instead of `IndexError` for consistency with other lionherd-core collections (Pile, Graph, Flow).

#### Before (v1.0.0-alpha4)

```python
from lionherd_core import Progression
from uuid import uuid4

prog = Progression(order=[uuid4()])

# IndexError raised for out-of-bounds access
try:
    prog.pop(10)  # Index 10 doesn't exist
except IndexError:
    print("Index out of range")

# IndexError raised for empty progression
empty_prog = Progression()
try:
    empty_prog.popleft()
except IndexError:
    print("Cannot pop from empty")
```

#### After (v1.0.0-alpha5)

```python
from lionherd_core import Progression
from lionherd_core.errors import NotFoundError
from uuid import uuid4

prog = Progression(order=[uuid4()])

# NotFoundError raised for out-of-bounds access
try:
    prog.pop(10)  # Index 10 doesn't exist
except NotFoundError:
    print("Index out of range")

# NotFoundError raised for empty progression
empty_prog = Progression()
try:
    empty_prog.popleft()
except NotFoundError:
    print("Cannot pop from empty")
```

#### Migration Steps

1. **Update exception handlers for pop() without default**:

```python
# Before
try:
    item = progression.pop(index)
except IndexError:
    handle_not_found()

# After
from lionherd_core.errors import NotFoundError

try:
    item = progression.pop(index)
except NotFoundError:
    handle_not_found()
```

2. **Update exception handlers for popleft()**:

```python
# Before
try:
    first = progression.popleft()
except IndexError:
    handle_empty()

# After
from lionherd_core.errors import NotFoundError

try:
    first = progression.popleft()
except NotFoundError:
    handle_empty()
```

3. **Use default parameter to avoid exceptions** (recommended):

```python
# ✅ Recommended approach - use default parameter
item = progression.pop(index, default=None)
if item is not None:
    process(item)

# Or with sentinel value
from lionherd_core.types import Undefined

item = progression.pop(index, default=Undefined)
if item is not Undefined:
    process(item)
```

#### Rationale

**Semantic consistency**: "Index not found" is semantically the same as "item not found" - both indicate lookup failure.

**Unified error handling**: Using `NotFoundError` across all collections (Pile, Graph, Flow, Progression) enables consistent error handling:

```python
from lionherd_core.errors import NotFoundError

try:
    # Works for all collections
    item1 = pile.get(uuid)
    item2 = graph.nodes[uuid]
    item3 = flow.items[uuid]
    item4 = progression[index]
except NotFoundError:
    # Single handler for all "not found" scenarios
    handle_missing_item()
```

**Exception metadata preserved**: `NotFoundError` includes `.details` dict with context:

```python
try:
    progression.pop(100)
except NotFoundError as e:
    print(e.details)
    # {'index': 100, 'length': 5}
```

#### Common Pitfalls

**Pitfall 1: Catching wrong exception type**

```python
# ❌ WRONG - Will not catch NotFoundError
try:
    progression.pop()
except IndexError:  # NotFoundError inherits from ValueError, not IndexError
    handle_error()

# ✅ CORRECT
from lionherd_core.errors import NotFoundError

try:
    progression.pop()
except NotFoundError:
    handle_error()
```

**Pitfall 2: Relying on except clause ordering**

```python
# ❌ WRONG - NotFoundError doesn't inherit from IndexError
try:
    progression.pop()
except (IndexError, ValueError):  # Won't catch NotFoundError
    handle_error()

# ✅ CORRECT - Import and catch explicitly
from lionherd_core.errors import NotFoundError

try:
    progression.pop()
except NotFoundError:
    handle_error()
```

---

## Flow Changes

### 8. Flow Constructor Redesign

**Breaking Change**: Flow `__init__` signature and behavior redesigned to support frozen type fields and referential integrity validation.

#### Before (v1.0.0-alpha4)

```python
from lionherd_core import Flow, Node

# Simple initialization
flow = Flow(
    items=[node1, node2],
    name="my_flow",
    item_type=MyNode,
    strict_type=True
)
# Behind the scenes: Created default Piles, then mutated frozen fields (bug!)
```

#### After (v1.0.0-alpha5)

```python
from lionherd_core import Flow, Progression, Node
from lionherd_core import Pile

# Enhanced initialization
flow = Flow(
    items=[node1, node2],      # list[E] | Pile[E] | Element
    progressions=[prog1],      # NEW: list[P] | Pile[P] (optional)
    name="my_flow",
    item_type=MyNode,          # Passed to items Pile
    strict_type=True,          # Passed to items Pile
)
# Behind the scenes: Creates configured Pile upfront (respects frozen fields)
```

#### Migration Steps

1. **Basic usage unchanged** (fully backward compatible):

```python
# ✅ This still works
flow = Flow(items=[node1, node2], name="workflow")
```

2. **Type validation now applied correctly**:

```python
# Before - type config might not be applied correctly
flow = Flow(items=[node1, node2], item_type=MyNode, strict_type=True)

# After - same code, but now actually enforces type config
flow = Flow(items=[node1, node2], item_type=MyNode, strict_type=True)
```

3. **Can now pass Pile directly** (preserves configuration):

```python
# Before - had to convert to list (lost configuration)
pile = Pile(items=[node1, node2], item_type=MyNode, strict_type=True)
flow = Flow(items=list(pile))  # Lost type config!

# After - pass Pile directly
pile = Pile(items=[node1, node2], item_type=MyNode, strict_type=True)
flow = Flow(items=pile)  # ✅ Configuration preserved
```

4. **New `progressions` parameter** (optional):

```python
# Before - had to add progressions after creation
flow = Flow(items=[node1, node2])
flow.add_progression(prog1)
flow.add_progression(prog2)

# After - can pass at initialization
flow = Flow(
    items=[node1, node2],
    progressions=[prog1, prog2]  # ✅ New parameter
)
```

#### Rationale

**Previous design violated frozen field constraint**:

```python
# v1.0.0-alpha4 internal implementation (buggy)
def __init__(self, item_type=None, strict_type=False):
    self.items = Pile()  # Created with defaults
    self.items.item_type = item_type  # ❌ Mutated frozen field!
    self.items.strict_type = strict_type  # ❌ Mutated frozen field!
```

**New design creates correctly configured Pile upfront**:

```python
# v1.0.0-alpha5 internal implementation (correct)
def __init__(self, items, item_type=None, strict_type=False):
    if isinstance(items, Pile):
        self.items = items  # Use existing Pile
    else:
        # Create Pile with correct configuration
        self.items = Pile(
            items=items,
            item_type=item_type,
            strict_type=strict_type
        )  # ✅ Configuration set at construction
```

**Benefits**:

- Respects frozen field invariant
- Accepts Pile directly (eliminates conversion overhead)
- Validates referential integrity upfront ([see next section](#9-flow-referential-integrity-validation))
- Supports progressions at initialization

---

### 9. Flow Referential Integrity Validation

**Breaking Change**: Flow now validates that all progression UUIDs exist in items pile at construction.

#### Before (v1.0.0-alpha4)

```python
from lionherd_core import Flow, Progression, Node

node1 = Node(content={"x": 1})
prog = Progression(order=[node1.id, uuid4(), uuid4()])  # References missing nodes

# Allowed - silent referential integrity violation
flow = Flow(items=[node1], progressions=[prog])
```

#### After (v1.0.0-alpha5)

```python
from lionherd_core import Flow, Progression, Node
from lionherd_core.errors import NotFoundError

node1 = Node(content={"x": 1})
missing_id1, missing_id2 = uuid4(), uuid4()
prog = Progression(order=[node1.id, missing_id1, missing_id2])

# Raises exception - referential integrity enforced
flow = Flow(items=[node1], progressions=[prog])
# ❌ NotFoundError: Progression contains UUIDs not in items pile:
#    {UUID('...'), UUID('...')}
```

#### Migration Steps

1. **Ensure all referenced items exist before creating Flow**:

```python
# Before - could create invalid Flow
prog = Progression(order=[node1.id, node2.id, node3.id])
flow = Flow(items=[node1], progressions=[prog])  # node2, node3 missing!

# After - add all items first
flow = Flow(
    items=[node1, node2, node3],  # ✅ All referenced items present
    progressions=[prog]
)
```

2. **Or add items incrementally, then add progressions**:

```python
# Create Flow with initial items
flow = Flow(items=[node1])

# Add missing items
flow.add_item(node2)
flow.add_item(node3)

# Now safe to add progression
flow.add_progression(prog)  # ✅ All references valid
```

3. **Filter progression to only include existing items**:

```python
# If progression might contain invalid references
existing_ids = {item.id for item in items}
valid_order = [uuid for uuid in prog.order if uuid in existing_ids]
prog_filtered = Progression(order=valid_order)

flow = Flow(items=items, progressions=[prog_filtered])
```

#### Error Message

```python
from lionherd_core import Flow, Progression
from uuid import uuid4

missing1, missing2 = uuid4(), uuid4()
prog = Progression(order=[node1.id, missing1, missing2])

try:
    flow = Flow(items=[node1], progressions=[prog])
except NotFoundError as e:
    print(e)
    # NotFoundError: Progression 'prog_name' contains 2 UUIDs not in items pile:
    # {UUID('...'), UUID('...')}
```

#### Rationale

Prevents construction of invalid Flow state:

- **Fail-fast**: Catches referential integrity errors at construction (not runtime)
- **Data consistency**: Guarantees all progression references are valid
- **Single validation**: O(n) cost at construction vs checking on every operation
- **Clear errors**: Immediately identifies missing items with specific UUIDs

Previous behavior allowed creating Flow with "dangling references" that would cause errors later during traversal.

---

### 10. Flow Parameter and Behavior Changes

#### Breaking Change A: add_item() Parameter Renamed

**`progression_ids` → `progressions`** for consistency with field name.

##### Before (v1.0.0-alpha4)

```python
from lionherd_core import Flow

flow.add_item(item, progression_ids=["stage1", uuid2])
```

##### After (v1.0.0-alpha5)

```python
from lionherd_core import Flow

flow.add_item(item, progressions=["stage1", uuid2])  # ✅ Renamed
```

##### Migration

Simple search and replace:

```python
# Find all occurrences of
flow.add_item(..., progression_ids=...)

# Replace with
flow.add_item(..., progressions=...)
```

##### Rationale

- **Consistency**: Matches field name (`flow.progressions`)
- **Clarity**: "progressions" is more intuitive than "progression_ids" (which could mean IDs or names)

---

#### Breaking Change B: remove_item() Always Removes from Progressions

**`remove_from_progressions` parameter removed** - removal always affects all progressions.

##### Before (v1.0.0-alpha4)

```python
from lionherd_core import Flow

# Could preserve progression references
flow.remove_item(item_id, remove_from_progressions=False)  # Kept in progressions

# Or remove from progressions
flow.remove_item(item_id, remove_from_progressions=True)   # Removed everywhere
```

##### After (v1.0.0-alpha5)

```python
from lionherd_core import Flow

# Always removes from all progressions
flow.remove_item(item_id)  # Removed from items AND all progressions
```

##### Migration

1. **For simple removals** (no code change needed):

```python
# Before
flow.remove_item(item_id, remove_from_progressions=True)

# After
flow.remove_item(item_id)  # Default behavior
```

2. **If you need to keep progression references**, manually remove first:

```python
# Before - could preserve progression references
flow.remove_item(item_id, remove_from_progressions=False)

# After - if you really need item in pile but not progressions:
# Option 1: Remove from progressions manually first
for prog in flow.progressions:
    if item_id in prog:
        prog.remove(item_id)
# Then remove from items (won't affect progressions since already removed)
flow.items.remove(item_id)

# Option 2: Don't remove, just exclude from progressions
for prog in flow.progressions:
    if item_id in prog:
        prog.remove(item_id)
# Item remains in flow.items
```

##### Rationale

**Allowing items in pile but not in any progression creates orphaned items**:

- **Memory leaks**: Unused items accumulate in pile
- **Confusion**: Items present but not accessible via progressions
- **Referential integrity**: Breaks assumption that progressions reference items in pile

**New behavior maintains consistency**:

- Removing item removes all references (no orphans)
- Simplifies API (one obvious way)
- Prevents memory leaks in long-running workflows

---

## Protocol Changes

### 11. @implements() Strict Enforcement

**Breaking Change**: `@implements()` now strictly enforces that protocol methods are defined in the class body, not inherited.

#### Before (v1.0.0-alpha4)

```python
from lionherd_core.protocols import Observable, Serializable, implements
from uuid import uuid4

class Parent:
    def __init__(self):
        self.id = uuid4()

    def to_dict(self):
        return {"id": str(self.id)}

# This was allowed (inherited methods counted)
@implements(Observable, Serializable)
class Child(Parent):
    pass  # No methods defined, but inherited from Parent
```

#### After (v1.0.0-alpha5)

```python
from lionherd_core.protocols import Observable, Serializable, implements
from uuid import uuid4

class Parent:
    def __init__(self):
        self.id = uuid4()

    def to_dict(self):
        return {"id": str(self.id)}

# This now raises TypeError
@implements(Observable, Serializable)
class Child(Parent):
    pass
# ❌ TypeError: Child claims to implement Observable but does not define required methods: ['__init__']
#    Child claims to implement Serializable but does not define required methods: ['to_dict']
```

#### Correct Usage

```python
# ✅ CORRECT: Define methods in class body
@implements(Observable, Serializable)
class Child(Parent):
    def __init__(self):
        super().__init__()  # Explicitly call parent

    def to_dict(self):
        return super().to_dict()  # Explicitly delegate

# ✅ CORRECT: Or just implement without @implements if relying on inheritance
class Child(Parent):  # No @implements needed
    pass  # Inherits Observable and Serializable behavior
```

#### Migration Steps

1. **For classes using `@implements()` with inherited methods**, explicitly define methods:

```python
# Before
@implements(Observable, Serializable)
class MyClass(Element):
    pass  # Relied on Element providing id and to_dict()

# After - Option 1: Define methods explicitly
@implements(Observable, Serializable)
class MyClass(Element):
    def __init__(self, **kwargs):
        super().__init__(**kwargs)

    def to_dict(self, **kwargs):
        return super().to_dict(**kwargs)

# After - Option 2: Remove @implements (rely on inheritance)
class MyClass(Element):
    pass  # Element already provides Observable/Serializable
```

2. **For custom protocols**, document which methods must be defined:

```python
from typing import Protocol

class MyProtocol(Protocol):
    """Custom protocol.

    Required methods (must be defined in class body):
    - custom_method() -> str
    """
    def custom_method(self) -> str: ...
```

#### Rationale

Enforces **explicit capability declaration** (Rust-like trait implementation):

- **Explicitness**: Reader can see what protocols are implemented without checking inheritance chain
- **Self-documentation**: Class body shows protocol contract
- **Prevents accidental compliance**: Inheritance providing methods is coincidence, not declaration
- **Structural typing**: Matches Protocol semantics (structural, not nominal)

**Design philosophy**: If you claim to implement a protocol via `@implements()`, you must show the implementation in your class body.

---

### 12. Adaptable Protocol Split

**Breaking Change**: `Adaptable`/`AsyncAdaptable` split from registry mutation. Classes now explicitly compose capabilities.

#### Before (v1.0.0-alpha4)

```python
from lionherd_core.protocols import Adaptable, implements

# Adaptable provided both adaptation AND registration
@implements(Adaptable)
class MyClass:
    def adapt_to(self, format, **kwargs): ...
    def adapt_from(self, format, data, **kwargs): ...
    # Also had: register_adapter() (mutation)
```

#### After (v1.0.0-alpha5)

```python
from lionherd_core.protocols import Adaptable, AdapterRegisterable, implements

# Separate protocols for read vs write
@implements(Adaptable, AdapterRegisterable)
class MyClass:
    # Adaptable (read-only)
    def adapt_to(self, format, **kwargs): ...
    def adapt_from(self, format, data, **kwargs): ...

    # AdapterRegisterable (mutation)
    def register_adapter(self, adapter): ...
```

#### Protocols

**Read-only adaptation**:

- `Adaptable` - sync adaptation (`adapt_to`, `adapt_from`)
- `AsyncAdaptable` - async adaptation (`adapt_to_async`, `adapt_from_async`)

**Mutable registry**:

- `AdapterRegisterable` - register sync adapters (`register_adapter`)
- `AsyncAdapterRegisterable` - register async adapters (`register_adapter`)

#### Migration Steps

1. **If class only uses adaptation** (no registration), no change needed:

```python
# ✅ Still works - just using read-only protocol
@implements(Adaptable)
class MyClass(Node):
    # Uses inherited adapt_to/adapt_from
    pass
```

2. **If class registers custom adapters**, add `AdapterRegisterable`:

```python
from pydapter.adapters import TomlAdapter

# Before
@implements(Adaptable)
class MyClass(Node):
    pass

MyClass.register_adapter(TomlAdapter)

# After - add AdapterRegisterable
@implements(Adaptable, AdapterRegisterable)
class MyClass(Node):
    pass

MyClass.register_adapter(TomlAdapter)  # Now explicit
```

3. **For async adaptation + registration**:

```python
# Both protocols
@implements(AsyncAdaptable, AsyncAdapterRegisterable)
class MyAsyncClass:
    async def adapt_to_async(self, format, **kwargs): ...
    async def adapt_from_async(self, format, data, **kwargs): ...
    def register_adapter(self, adapter): ...
```

#### Rationale

**Separation of concerns**:

- **Read-only adaptation**: Query capability (no side effects)
- **Registry mutation**: Modification capability (side effects)

**Benefits**:

- Explicit about mutability (classes declare if they allow custom adapters)
- Follows Command-Query Separation (CQS) principle
- Enables read-only adapter views (security/immutability)

**Note**: Built-in classes (Node, Pile, Graph) implement both by default.

---

## Testing After Migration

### Recommended Testing Strategy

1. **Unit test coverage** for all affected code:

```bash
# Run tests for specific modules
uv run pytest tests/unit/test_pile.py -v
uv run pytest tests/unit/test_flow.py -v
uv run pytest tests/unit/test_progression.py -v

# Full test suite
uv run pytest --cov=lionherd_core --cov-report=term-missing
```

2. **Integration tests** for workflow logic:

```python
# Test Flow referential integrity
def test_flow_integrity():
    nodes = [Node(content={"x": i}) for i in range(5)]
    prog = Progression(order=[n.id for n in nodes[:3]])

    # Should succeed (all references exist)
    flow = Flow(items=nodes, progressions=[prog])

    # Should fail (missing reference)
    missing_prog = Progression(order=[uuid4()])
    with pytest.raises(NotFoundError):
        Flow(items=nodes, progressions=[missing_prog])
```

3. **Smoke tests** for critical workflows:

```python
# Test end-to-end workflow
def test_workflow_smoke():
    # Create items
    pile = Pile(item_type=Task, strict_type=True)
    tasks = [Task(name=f"task_{i}") for i in range(10)]

    # Include items (new semantics)
    for task in tasks:
        assert pile.include(task)  # Guaranteed in pile

    # Create progressions
    prog1 = Progression(order=[t.id for t in tasks[:5]])
    prog2 = Progression(order=[t.id for t in tasks[5:]])

    # Create flow (validates integrity)
    flow = Flow(items=pile, progressions=[prog1, prog2])

    # Remove item (always removes from progressions)
    flow.remove_item(tasks[0].id)
    assert tasks[0].id not in flow.items
    assert tasks[0].id not in prog1
```

4. **Regression tests** for edge cases:

```python
def test_pile_include_idempotent():
    """Test include returns True for duplicate adds (guaranteed state)."""
    pile = Pile()
    node = Node(content={"x": 1})

    # First include
    assert pile.include(node) is True

    # Second include (idempotent)
    assert pile.include(node) is True  # Still True (guaranteed state)

def test_progression_validation_strict():
    """Test invalid items raise exception (no silent dropping)."""
    with pytest.raises(ValidationError):
        Progression(order=["not-a-uuid", uuid4()])
```

### What to Test

**Pile**:

- [ ] Type configuration set at initialization (not mutated)
- [ ] `include/exclude` return guaranteed state (not action taken)
- [ ] `.items()` method call (not property access)
- [ ] No async methods exist
- [ ] `list(pile)` works (no `.to_list()`)

**Progression**:

- [ ] Invalid items raise ValidationError (no silent dropping)
- [ ] Empty progressions are falsy (`bool(prog) is False`)
- [ ] Non-empty progressions are truthy

**Flow**:

- [ ] Type configuration passed to Pile correctly
- [ ] Referential integrity validated at construction
- [ ] `add_item(progressions=...)` parameter
- [ ] `remove_item()` always removes from progressions
- [ ] Can pass Pile directly to constructor

**Protocols**:

- [ ] `@implements()` requires methods in class body
- [ ] `AdapterRegisterable` needed for `register_adapter()`

---

## FAQ

### Why were type fields made frozen?

**A**: Type configuration is structural - changing it after initialization would invalidate existing items. Frozen fields prevent runtime type confusion and enable optimizations.

### Can I still change which items are in a Pile?

**A**: Yes! Only the `item_type` and `strict_type` configuration fields are frozen. You can still add/remove items freely:

```python
pile = Pile(item_type=Task, strict_type=True)  # Configuration frozen

# These still work
pile.add(task1)        # ✅ Add items
pile.remove(task1.id)  # ✅ Remove items
pile.include(task2)    # ✅ Idempotent add
```

### Why did include/exclude semantics change?

**A**: Previous semantics (True = action taken) required separate checks to know current state. New semantics (True = guaranteed state) make operations truly idempotent and useful for flow control.

### Do I need to change all my .keys() calls?

**A**: No. While the internal implementation changed (generator → Iterator), the API is identical. Your code continues to work:

```python
for uuid in pile.keys():  # ✅ Works in both versions
    item = pile[uuid]
```

### Why remove async Pile methods?

**A**: Pile operations are O(1) in-memory dict operations (CPU-bound, not I/O-bound). Async variants provided no performance benefit and complicated the API. Use `async with pile:` for thread-safe bulk operations.

### Will Progression silently drop invalid items?

**A**: No (changed in v1.0.0-alpha5). Invalid items now raise `ValidationError`:

```python
# v1.0.0-alpha4 (silent)
prog = Progression(order=[valid, invalid, valid])  # Dropped invalid

# v1.0.0-alpha5 (strict)
prog = Progression(order=[valid, invalid, valid])  # ❌ ValidationError
```

Filter invalid items before passing to Progression if needed.

### Can I still have items in Flow not in any Progression?

**A**: Yes, but not via `remove_item()`:

```python
# Items can exist without being in progressions
flow = Flow(items=[node1, node2, node3])
prog = Progression(order=[node1.id, node2.id])  # node3 not included
flow.add_progression(prog)

# node3 is in flow.items but not in any progression ✅

# But remove_item() always removes from everything:
flow.remove_item(node1.id)  # Removed from items AND progressions
```

### Why does @implements() require methods in class body?

**A**: Enforces explicit capability declaration (Rust-like trait implementation). If you claim to implement a protocol, you must show the implementation. Prevents accidental compliance via inheritance.

### Do I need AdapterRegisterable if I'm not registering custom adapters?

**A**: No. If you only use adaptation (read-only), just implement `Adaptable`:

```python
# Read-only (no registration)
@implements(Adaptable)
class ReadOnlyClass(Node):
    pass  # Uses inherited adapt_to/adapt_from

# With registration
@implements(Adaptable, AdapterRegisterable)
class CustomAdapterClass(Node):
    pass

CustomAdapterClass.register_adapter(MyAdapter)
```

### How do I handle Flow referential integrity errors?

**A**: Ensure all progression UUIDs exist in items before creating Flow:

```python
# Option 1: Add all items first
flow = Flow(items=[node1, node2, node3], progressions=[prog])

# Option 2: Filter progression to valid UUIDs
existing_ids = {item.id for item in items}
valid_order = [uuid for uuid in prog.order if uuid in existing_ids]
prog_filtered = Progression(order=valid_order)
flow = Flow(items=items, progressions=[prog_filtered])
```

---

## See Also

- [CHANGELOG.md](../../CHANGELOG.md) - Full list of changes
- [Pile API Reference](../api/base/pile.md) - Updated Pile documentation
- [Flow API Reference](../api/base/flow.md) - Updated Flow documentation
- [Progression API Reference](../api/base/progression.md) - Updated Progression documentation
- [Protocol Guide](#) - Protocol implementation guide (coming soon)

---

**Last Updated**: 2025-11-11
**Version**: 1.0.0-alpha5 (unreleased)
**Status**: Draft
